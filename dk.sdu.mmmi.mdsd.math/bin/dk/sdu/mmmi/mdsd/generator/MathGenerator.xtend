/*
 * generated by Xtext 2.25.0
 */
package dk.sdu.mmmi.mdsd.generator

import dk.sdu.mmmi.mdsd.math.Div
import dk.sdu.mmmi.mdsd.math.LetBinding
import dk.sdu.mmmi.mdsd.math.MathExp
import dk.sdu.mmmi.mdsd.math.MathNumber
import dk.sdu.mmmi.mdsd.math.Minus
import dk.sdu.mmmi.mdsd.math.Mult
import dk.sdu.mmmi.mdsd.math.Plus
import dk.sdu.mmmi.mdsd.math.VarBinding
import dk.sdu.mmmi.mdsd.math.VariableUse
import java.util.HashMap
import java.util.Map
import javax.swing.JOptionPane
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import dk.sdu.mmmi.mdsd.math.Expression
import dk.sdu.mmmi.mdsd.math.Parenthesis
import dk.sdu.mmmi.mdsd.math.ExternalBinding
import dk.sdu.mmmi.mdsd.math.ParameterUse

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MathGenerator extends AbstractGenerator {
	
	static Map<String, Integer> variables;

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		
		val math = resource.allContents.filter(MathExp).next
		val result = math.compute
		//result.displayPanel
		for(e : resource.allContents.toIterable.filter(MathExp)){
			fsa.generateFile("math_expression/" + e.name + ".java", e.compile)
		}
		
		
		
	}
	
 	
	def compile(MathExp math){
		'''
		package math_expression;
		public class «math.name» {
		
		 «FOR variable : math.variables»
		 public int «variable.name»;
		 «ENDFOR»
		 «IF(HasExternal(math))»
		 private External external;
		
		 public «math.name»(External external){
		  this.external = external;
		 }
	     «ENDIF»
		 public void compute(){
	     «FOR variable : math.variables»
	     «variable.name» = «variable.showExpression»;
	     «ENDFOR»
		 }
		 
		 «IF(HasExternal(math))»
		 interface External{
		 «FOR external : math.externals»
		 «val myArray = #['n','m', 'j', 'k']»
		 «var counter = 0»
		 public int «external.name»(«FOR param : external.param.params»«getComma(counter)»«param» «myArray.get(counter)»«{counter++; null}»«ENDFOR»);«ENDFOR»
		 }
		 «ENDIF»
		
		}
		
		
		
		'''
	}
	def HasExternal(MathExp math){
		if(math.externals.length > 0)
		return true
		else
		return false
	}
	
		
	def void displayPanel(Map<String, Integer> result) {
		var resultString = ""
		for (entry : result.entrySet()) {
         	resultString += "var " + entry.getKey() + " = " + entry.getValue() + "\n"
        }
		
		JOptionPane.showMessageDialog(null, resultString ,"Math Language", JOptionPane.INFORMATION_MESSAGE)
	}
	
	def static compute(MathExp math) {
		variables = new HashMap()
		for(varBinding: math.variables)
			varBinding.computeExpression()
		variables
	}
	

	def static dispatch int computeExpression(VarBinding binding) {
		variables.put(binding.name, binding.expression.computeExpression())
		return variables.get(binding.name)
	}
//void to allow generation
	def static dispatch int computeExpression(ExternalBinding binding) {
		if(binding.name == "pi"){
			return 3
		}
		if(binding.name == "sqrt"){
			var x = Math.sqrt(binding.params.exp.computeExpression)
			return x.intValue
		}
		if(binding.name == "pow"){
			var x = Math.pow(binding.params.exp.computeExpression, binding.params.exp2.computeExpression)
			return x.intValue
		}
	}
	
	
	def static dispatch int computeExpression(MathNumber exp) {
		exp.value
	}

	def static dispatch int computeExpression(Plus exp) {
		exp.left.computeExpression + exp.right.computeExpression
	}
	def static dispatch int computeExpression(Parenthesis exp) {
		exp.value.computeExpression
	}
	
	def static dispatch int computeExpression(Minus exp) {
		exp.left.computeExpression - exp.right.computeExpression
	}
	
	def static dispatch int computeExpression(Mult exp) {
		exp.left.computeExpression * exp.right.computeExpression
	}
	
	def static dispatch int computeExpression(Div exp) {
		exp.left.computeExpression / exp.right.computeExpression
	}

	def static dispatch int computeExpression(LetBinding exp) {
		exp.body.computeExpression
	}
	
	def static dispatch int computeExpression(VariableUse exp) {
		exp.ref.computeBinding
	}

	def static dispatch int computeBinding(VarBinding binding){
		if(!variables.containsKey(binding.name))
			binding.computeExpression()			
		variables.get(binding.name)
	}
	
	def static dispatch int computeBinding(LetBinding binding){
		binding.binding.computeExpression
	}
	
	
	
	def static dispatch String showExpression(VarBinding binding) {
	return binding.expression.showExpression
	}
	def static dispatch String showExpression(LetBinding binding) {
	return binding.body.computeExpression.toString
	}
	def static dispatch String showExpression(VariableUse exp) {
		exp.ref.showExpression
	}
	def static dispatch String showExpression(ExternalBinding ext) {
		'this.external.' + ext.name + '(' + ext.params.showExpression + ')'
	}
	def static dispatch String showExpression(ParameterUse ext) {
//		if(ext.expressions.size == 0)
//		return "0"
//		if(ext.expressions.size == 1)
//		return ext.expressions.get(0).showExpression
//		for(exp : ext.expressions){
//			return exp.showExpression
//		}	
		if(ext.exp2 != null)
		return ext.exp.showExpression + "," + ext.exp2.showExpression
		if(ext.exp != null)
		return ext.exp.showExpression
		else
		return ""
	}

	def static dispatch String showExpression(Plus exp) {
		exp.left.showExpression + ' + ' + exp.right.showExpression
	}
	
		def static dispatch String showExpression(Mult exp) {
		exp.left.showExpression + ' * ' + exp.right.showExpression
	}
		def static dispatch String showExpression(Minus exp) {
		exp.left.showExpression + ' - ' + exp.right.showExpression
	}
		def static dispatch String showExpression(Div exp) {
		exp.left.showExpression + ' / ' + exp.right.showExpression
	}
		def static dispatch String showExpression(Parenthesis exp) {
		"(" + exp.value.showExpression + ")"
	}
	def static dispatch String showExpression(MathNumber exp) {
		exp.value.toString
	}
	def char getNext(int counter){
		val char[] myArray = #['n','m', 'j', 'k']
		return myArray.get(counter)
	}
		def String getComma(int c){
		if(c > 0)
		return ','
		else
		return ''
	}
		
}
